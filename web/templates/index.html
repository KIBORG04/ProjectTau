{{ template "header.html" .}}

<div class="container mt-4">
    {{ template "ad.html" . }}
    <div class="row">
        <div class="col-lg-8">
            <div class="row">
                <div class="col">
                    <ul class="list-group list-group-flush">
                        <li class="list-group-item">Версия статистики: {{ .version }}</li>
                        <li class="list-group-item">Дата начала сбора статистики: {{ .firstDate }}</li>
                        <li class="list-group-item">Последнее обновление БД: {{ .lastDate }}</li>
                        <li class="list-group-item">Последний раунд в БД: {{ .lastRound }}</li>
                    </ul>
                </div>
                <div class="col">
                    <ul class="list-group list-group-flush">
                        <li class="list-group-item">Раундов в статистике: {{ .totalRounds }}</li>
                        <li class="list-group-item">Раундов на первом: {{ .alphaRounds }}</li>
                        <li class="list-group-item">Раундов на втором: {{ .betaRounds }}</li>
                        <li class="list-group-item">Раундов на третьем: {{ .gammaRounds }}</li>
                    </ul>
                </div>
            </div>
            <br>
            <div class="text-center border-bottom pb-2">
                <h4>Статистика по: <span id="online-stat-current-dates">Lorem ipsum</span></h4>
                <div class="alert-info">
                    Вы можете манипулировать графиками, изменяя даты вверху сайта
                    <div>
                        <input type="checkbox" id="toggleChronicles" checked>
                        Показывать важные события
                    </div>
                </div>
            </div>
            <div class="row">
                <h5 class="text-center border-bottom pb-2">Средний онлайн по неделям</h5>
                <canvas id="online-stat-all-weeks"></canvas>
            </div>
            <div class="row">
                <h5 class="text-center border-bottom pb-2">Средний онлайн по часам</h5>
                <canvas id="online-stat-daytime"></canvas>
            </div>
            <div class="row">
                <h5 class="text-center border-bottom pb-2">Средний онлайн за последние 90 дней</h5>
                <canvas id="online-stat-month"></canvas>
            </div>
        </div>
        <div class="col-sm-3 col-lg-4 mt-2">
            <div id="random_announce" class="mb-3"></div>
            <div id="random_achievement" class="mb-3"></div>
            <div id="random_flavor" class="mb-3"></div>
            <div id="random_last_phrase" class="mb-3"></div>
        </div>
    </div>
</div>

{{ template "footer.html" .}}

<script>
    function unescape(str) {
        return str.replace(/&amp;#34;/g, '"')
            .replace(/&amp;/g, '&')
            .replace(/&lt;/g, '<')
            .replace(/&gt;/g, '>')
            .replace(/&quot;/g, '"')
            .replace(/&#039;/g, "'")
    }

    function get_announce() {
        $.getJSON("/api/random_announce", function (data) {
            const author = data.Author ? `<figcaption class="blockquote-footer">${data.Author}</figcaption>` : ""
            const button = `<button id="update_announce" class="btn btn-outline-secondary btn-sm fa-solid fa-arrow-rotate-right float-md-end ms-2"></button>`
            $("#random_announce").html(`
               <figure class="text-end">
                            <p class="h5">${button}${data.Title}</p>
                            <p id="announce_contents" class="fs-6"></p>
                             ${author}
               </figure>`)
            $("#announce_contents").text(unescape(data.Content))
            $("#update_announce").click(get_announce)
        })
    }

    function get_achievement() {
        $.getJSON("/api/random_achievement", function (data) {
            const button = `<button id="update_achievement" class="btn btn-outline-secondary btn-sm fa-solid fa-arrow-rotate-right float-md-end ms-2"></button>`
            $("#random_achievement").html(`
               <figure class="text-end">
                            <p class="h5">${button}${data.Title}</p>
                            <p id="achievement_contents" class="fs-6"></p>
                            <figcaption class="blockquote-footer">
                                ${data.Key} as ${data.Name}
                            </figcaption>
               </figure>`)
            $("#achievement_contents").text(unescape(data.Desc))
            $("#update_achievement").click(get_achievement)
        })
    }

    function get_flavor() {
        $.getJSON("/api/random_flavor", function (data) {
            const button = `<button id="update_flavor" class="btn btn-outline-secondary btn-sm fa-solid fa-arrow-rotate-right float-md-end ms-2"></button>`
            $("#random_flavor").html(`
               <figure class="text-end">
                            <p class="h5">${button}${data.Name}</p>
                            <p id="flavor_contents" class="fs-6"></p>
                            <figcaption class="blockquote-footer" style="text-transform:capitalize;">
                                ${data.Gender}, ${data.Age}, ${data.Species}
                            </figcaption>
               </figure>`)
            $("#flavor_contents").text(unescape(data.Flavor))
            $("#update_flavor").click(get_flavor)
        })
    }

    function get_last_phrase() {
        $.getJSON("/api/random_last_phrase", function (data) {
            const button = `<button id="update_last_phrase" class="btn btn-outline-secondary btn-sm fa-solid fa-arrow-rotate-right float-md-end ms-2"></button>`
            $("#random_last_phrase").html(`
               <figure class="text-end">
                            <p class="h5">${button}Перед смертью в ${data.TimeOfDeath}</p>
                            <p class="fs-6"><span style='font-weight: 500;'>${data.Name}</span>: "${data.Phrase}"</p>
                            <figcaption class="blockquote-footer">
                                Round #${data.RoundID}
                            </figcaption>
               </figure>`)
            $("#update_last_phrase").click(get_last_phrase)
        })
    }

    $("#date_start").change(function () {
        get_online_charts();
    });

    $("#date_end").change(function () {
        get_online_charts();
    });

    let showChronicles = true;
    $("#toggleChronicles").change(function() {
        showChronicles = this.checked;

        // Обновляем все графики
        ['online-stat-all-weeks', 'online-stat-daytime', 'online-stat-month'].forEach(id => {
            const chart = Chart.getChart(id);
            if (chart) {
                chart.update();
            }
        });
    });

    async function get_online_charts() {
        const menuDateStart = document.getElementById('date_start').value;
        const menuDateEnd = document.getElementById('date_end').value;

        $("#online-stat-current-dates").html(`
            <span class="text-danger">${menuDateStart}</span> - <span class="text-success">${menuDateEnd}</span>
            `);

        // важна синхронность только доя графика online-stat-month
        for (let id of ['online-stat-all-weeks', 'online-stat-daytime', 'online-stat-month']) {
            let existingChart = Chart.getChart(id);
            if (existingChart) {
                existingChart.destroy();
            }
        }

        await getChronicles()

        // 1. Рисуем график с реальными данными
        await get_online_chart("online-stat-all-weeks", "online_stat_weeks", "Players, avg", menuDateStart, menuDateEnd)
        
        // 2. Добавляем на него ИСТОРИЧЕСКИЙ прогноз (например, недельной давности)
        await add_historical_forecast_to_chart(
            "online-stat-all-weeks", 
            "Прогноз (7 дней назад)", 
            { type: 'weekly', days_ago: 7 }
        );

        // 3. Добавляем на него АКТУАЛЬНЫЙ прогноз на будущее
        await add_forecast_to_weekly_chart("online-stat-all-weeks", "online_stat_weeks_forecast", "Прогноз (актуальный)", menuDateStart, menuDateEnd);

        // --- Для дневного графика то же самое ---
        await get_online_chart("online-stat-daytime", "online_stat_daytime", "players, avg", menuDateStart, menuDateEnd)

        const dateTo = new Date()
        const dateFrom = new Date()
        dateTo.setDate(dateTo.getDate() - 1) // without today
        dateFrom.setDate(dateTo.getDate() - 90)

        await get_online_chart("online-stat-month", "online_stat", "players, avg", format_date(dateFrom), format_date(dateTo))
        await get_online_chart("online-stat-month", "online_stat_max", "players, max", format_date(dateFrom), format_date(dateTo))

        // Добавляем исторический дневной прогноз (например, вчерашний)
        await add_historical_forecast_to_chart(
            "online-stat-month", 
            "Прогноз (вчера)", 
            { type: 'daily', days_ago: 1 }
        );

        await add_forecast_to_daily_chart("online-stat-month", "online_stat_daily_forecast", "Прогноз (актуальный)");
    }

    // НОВАЯ ФУНКЦИЯ для отрисовки исторического прогноза
    function add_historical_forecast_to_chart(targetId, label, params) {
        return new Promise((resolve) => {
            $.ajax({
                url: `/api/historical_forecast`,
                data: params, // { type: 'weekly', days_ago: 7 }
                success: function(historicalData) {
                    const chart = Chart.getChart(targetId);
                    if (!chart || Object.keys(historicalData).length === 0) {
                        resolve();
                        return;
                    }

                    const historicalLabels = Object.keys(historicalData);
                    const historicalValues = Object.values(historicalData);

                    // Создаем датасет, который будет накладываться на существующие данные
                    const datasetData = [];
                    // Сопоставляем исторические данные с основной шкалой графика
                    chart.data.labels.forEach(label => {
                        if (historicalData[label] !== undefined) {
                            datasetData.push(historicalData[label]);
                        } else {
                            datasetData.push(null); // Пропуски, где нет данных
                        }
                    });

                    chart.data.datasets.push({
                        label: label,
                        data: datasetData,
                        borderColor: 'rgba(150, 150, 150, 0.7)', // Серый цвет
                        borderWidth: 2,
                        borderDash: [2, 2], // Мелкий пунктир
                        fill: false,
                        tension: 0.1,
                        pointRadius: 2,
                    });
                    
                    chart.update();
                    resolve();
                },
                error: function(error) {
                    console.error(`Не удалось получить исторический прогноз для ${targetId}:`, error);
                    resolve();
                }
            });
        });
    }

    let datasetCounter = 1;
    function get_online_chart(targetId, endpoint, label, dateFrom, dateTo) {
        // Promise теперь всегда вызывает resolve(), чтобы не блокировать другие графики
        return new Promise((resolve) => {
            $.ajax({
                url: `/api/${endpoint}`,
                data: {dateFrom: dateFrom, dateTo: dateTo},
                success: function (data) {
                    const maxOnline = Math.max(...Object.values(data));
                    const chart = Chart.getChart(targetId);
                
                    const newLabels = Object.keys(data);
                    const newData = Object.values(data);
                
                    const chroniclesInRange = endpoint === 'online_stat_weeks'
                        ? getChroniclesForWeeks(newLabels)
                        : getChroniclesInRange(newLabels, dateFrom, dateTo);
                
                    if (chart) {
                        chart.data.datasets.push({
                            label: label,
                            data: newData,
                            borderWidth: 1,
                        });
                        chart.update();
                        
                        // ИСПРАВЛЕНИЕ №1: Вызываем resolve() после обновления графика
                        resolve();
                        return;
                    }
                
                    new Chart(
                        $("#" + targetId),
                        {
                            type: 'line',
                            data: {
                                labels: newLabels,
                                datasets: [{
                                    label: label,
                                    data: newData,
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                plugins: {
                                    colors: {
                                        forceOverride: true
                                    },
                                    tooltip: {
                                        callbacks: {
                                            afterBody: function(context) {
                                                const label = context[0].label;
                                                if (chroniclesInRange.find(c => c.date === label)) {
                                                    const chronicle = chroniclesInRange.find(c => c.date === label);
                                                    return `Events:\n${chronicle.text.split('|').join('\n')}`;
                                                }
                                                return null;
                                            }
                                        }
                                    }
                                },
                                scales: {
                                    y: {
                                        suggestedMin: 0,
                                        suggestedMax: maxOnline + 10
                                    }
                                }
                            },
                            plugins: [{
                                id: 'chroniclesPlugin',
                                afterDraw: function(chart) {
                                    if (!showChronicles) return;
                                    const ctx = chart.ctx;
                                    const xAxis = chart.scales.x;
                                    const yAxis = chart.scales.y;
                                
                                    chroniclesInRange.forEach(chronicle => {
                                        const xPos = xAxis.getPixelForValue(chronicle.date);
                                    
                                        ctx.save();
                                        ctx.beginPath();
                                        ctx.moveTo(xPos, yAxis.top);
                                        ctx.lineTo(xPos, yAxis.bottom);
                                        ctx.lineWidth = 2;
                                        ctx.strokeStyle = 'rgba(128, 128, 128, 0.3)';
                                        ctx.stroke();
                                        ctx.restore();
                                    });
                                },
                                afterEvent: function(chart, args) {
                                    if (!showChronicles || args.event.type !== 'mousemove') return;
                                    if (args.event.type === 'mousemove') {
                                        const xAxis = chart.scales.x;
                                        const yAxis = chart.scales.y;
                                        const ctx = chart.ctx;
                                        const mouseX = args.event.x;
                                        let closestChronicle = null;
                                        let minDistance = Infinity;
                                        chroniclesInRange.forEach(chronicle => {
                                            const xPos = xAxis.getPixelForValue(chronicle.date);
                                            const distance = Math.abs(mouseX - xPos);
                                            if (distance < 50 && distance < minDistance) {
                                                minDistance = distance;
                                                closestChronicle = chronicle;
                                            }
                                        });
                                        if (closestChronicle) {
                                            const xPos = xAxis.getPixelForValue(closestChronicle.date);
                                            chart.draw();
                                            ctx.save();
                                            ctx.beginPath();
                                            ctx.moveTo(xPos, yAxis.top);
                                            ctx.lineTo(xPos, yAxis.bottom);
                                            ctx.lineWidth = 3;
                                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                                            ctx.stroke();
                                            const events = closestChronicle.text.split('|');
                                            ctx.font = '12px Arial';
                                            const lineHeight = 16;
                                            let maxWidth = 0;
                                            events.forEach(event => {
                                                const width = ctx.measureText(event).width;
                                                maxWidth = Math.max(maxWidth, width);
                                            });
                                            const padding = 10;
                                            const rectWidth = maxWidth + padding * 2;
                                            const rectHeight = events.length * lineHeight + padding * 2;
                                            const centerX = chart.width / 2;
                                            const centerY = 55;
                                            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                                            ctx.lineWidth = 1;
                                            const radius = 5;
                                            ctx.beginPath();
                                            ctx.moveTo(centerX - rectWidth / 2 + radius, centerY - rectHeight / 2);
                                            ctx.lineTo(centerX + rectWidth / 2 - radius, centerY - rectHeight / 2);
                                            ctx.quadraticCurveTo(centerX + rectWidth / 2, centerY - rectHeight / 2, centerX + rectWidth / 2, centerY - rectHeight / 2 + radius);
                                            ctx.lineTo(centerX + rectWidth / 2, centerY + rectHeight / 2 - radius);
                                            ctx.quadraticCurveTo(centerX + rectWidth / 2, centerY + rectHeight / 2, centerX + rectWidth / 2 - radius, centerY + rectHeight / 2);
                                            ctx.lineTo(centerX - rectWidth / 2 + radius, centerY + rectHeight / 2);
                                            ctx.quadraticCurveTo(centerX - rectWidth / 2, centerY + rectHeight / 2, centerX - rectWidth / 2, centerY + rectHeight / 2 - radius);
                                            ctx.lineTo(centerX - rectWidth / 2, centerY - rectHeight / 2 + radius);
                                            ctx.quadraticCurveTo(centerX - rectWidth / 2, centerY - rectHeight / 2, centerX - rectWidth / 2 + radius, centerY - rectHeight / 2);
                                            ctx.closePath();
                                            ctx.fill();
                                            ctx.stroke();
                                            ctx.fillStyle = 'white';
                                            ctx.textAlign = 'center';
                                            ctx.textBaseline = 'middle';
                                            events.forEach((event, index) => {
                                                const yPos = centerY - rectHeight / 2 + padding + lineHeight / 2 + index * lineHeight;
                                                ctx.fillText(event, centerX, yPos);
                                            });
                                            ctx.restore();
                                        }
                                    }
                                }
                            }]
                        }
                    );
                    resolve();
                },
                // ИСПРАВЛЕНИЕ №2: Добавляем обработчик ошибок
                error: function(jqXHR, textStatus, errorThrown) {
                    console.error(`Ошибка при загрузке данных для графика '${targetId}' с эндпоинта '${endpoint}':`, textStatus, errorThrown);
                    // Вызываем resolve() даже при ошибке, чтобы остальные графики продолжили загружаться.
                    resolve();
                }
            });
        });
    }
    
    /**
     * Новая функция для добавления данных прогноза на график среднего онлайна по неделям.
     * @param {string} targetId - ID canvas элемента графика.
     * @param {string} endpoint - API endpoint для получения данных прогноза.
     * @param {string} label - Название для линии прогноза.
     * @param {string} dateFrom - Начальная дата (может понадобиться бэкенду).
     * @param {string} dateTo - Конечная дата (может понадобиться бэкенду).
     */
    function add_forecast_to_weekly_chart(targetId, endpoint, label, dateFrom, dateTo) {
        return new Promise((resolve) => {
            $.ajax({
                url: `/api/${endpoint}`,
                data: {dateFrom: dateFrom, dateTo: dateTo},
                success: function(forecastData) {
                    const chart = Chart.getChart(targetId);
                    // Проверяем, что график и его данные существуют
                    if (!chart || !chart.data.datasets[0] || chart.data.datasets[0].data.length === 0) {
                        resolve();
                        return;
                    }

                    const forecastLabels = Object.keys(forecastData);
                    const forecastValues = Object.values(forecastData);

                    // Если данных прогноза нет, ничего не делаем
                    if (forecastLabels.length === 0) {
                        resolve();
                        return;
                    }

                    // Получаем исторические данные из графика
                    const historicalLabels = chart.data.labels;
                    const historicalDataset = chart.data.datasets[0];
                    const lastHistoricalValue = historicalDataset.data[historicalDataset.data.length - 1];

                    // Создаем массив данных для линии прогноза
                    // Он заполнен null для всех исторических точек, кроме последней
                    const forecastDatasetData = new Array(historicalLabels.length - 1).fill(null);
                    
                    // Первая точка прогноза равна последней точке истории, чтобы линия была непрерывной
                    forecastDatasetData.push(lastHistoricalValue);

                    // Добавляем фактические значения прогноза
                    forecastDatasetData.push(...forecastValues);

                    // Объединяем метки (недели) и добавляем новый набор данных (dataset) на график
                    chart.data.labels.push(...forecastLabels);
                    chart.data.datasets.push({
                        label: label,
                        data: forecastDatasetData,
                        borderColor: 'rgba(255, 99, 132, 1)', // Красный цвет для прогноза
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        borderWidth: 2,
                        borderDash: [5, 5], // Пунктирная линия
                        fill: false, // Не заливать область под линией
                        tension: 0.1,
                    });

                    chart.update(); // Обновляем график для отображения изменений
                    resolve();
                },
                error: function(error) {
                    console.error(`Не удалось получить данные прогноза из ${endpoint}:`, error);
                    // Не прерываем выполнение, чтобы остальные графики загрузились
                    resolve();
                }
            });
        });
    }

    // Эта функция добавляет прогноз на 90-дневный график (ИСПРАВЛЕННАЯ ВЕРСИЯ)
    function add_forecast_to_daily_chart(targetId, endpoint, label) {
        return new Promise((resolve) => {
            $.ajax({
                url: `/api/${endpoint}`, // Даты не нужны, бэкенд берет последние 180 дней
                success: function(forecastData) {
                    // ИСПРАВЛЕНИЕ №1: Используем Chart.getChart вместо chartInstances
                    const chart = Chart.getChart(targetId); 
                    if (!chart || !chart.data.datasets[0] || chart.data.datasets[0].data.length === 0) {
                        resolve(); 
                        return;
                    }

                    const forecastLabels = Object.keys(forecastData);
                    const forecastValues = Object.values(forecastData);

                    if (forecastLabels.length === 0) {
                        resolve();
                        return;
                    }

                    // ИСПРАВЛЕНИЕ №2: Ищем набор данных с правильным label 'players, avg'
                    const avgDatasetIndex = chart.data.datasets.findIndex(d => d.label === 'players, avg');
                    if (avgDatasetIndex === -1) { 
                        console.error("Не найден набор данных 'players, avg' для добавления прогноза.");
                        resolve(); 
                        return; 
                    }

                    const historicalDataset = chart.data.datasets[avgDatasetIndex];
                    const lastHistoricalValue = historicalDataset.data[historicalDataset.data.length - 1];

                    // Создаем массив данных для линии прогноза
                    const forecastDatasetData = new Array(chart.data.labels.length - 1).fill(null);
                    forecastDatasetData.push(lastHistoricalValue); // Соединяем с последней точкой
                    forecastDatasetData.push(...forecastValues); // Добавляем сам прогноз

                    // Добавляем новые метки (даты) на ось X, если их еще нет
                    const existingLabels = new Set(chart.data.labels);
                    const newLabelsToAdd = forecastLabels.filter(l => !existingLabels.has(l));
                    chart.data.labels.push(...newLabelsToAdd);

                    // Добавляем новый набор данных (саму линию прогноза) на график
                    chart.data.datasets.push({
                        label: label,
                        data: forecastDatasetData,
                        borderColor: 'rgba(75, 192, 192, 1)', // Бирюзовый цвет
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderWidth: 2,
                        borderDash: [5, 5], // Пунктирная линия
                        fill: false,
                        tension: 0.1,
                    });

                    chart.update(); // Перерисовываем график
                    resolve();
                },
                error: function(error) {
                    console.error(`Не удалось получить данные дневного прогноза:`, error);
                    resolve(); // Не ломаем страницу, если прогноз не загрузился
                }
            });
        });
    }


    // Новая функция для обработки недельных интервалов
    function getChroniclesForWeeks(weekLabels) {
        const result = [];

        weekLabels.forEach(weekLabel => {
            const [year, week] = weekLabel.split('-').map(Number);
            const weekDates = getDatesOfWeek(year, week);
            const weekEvents = [];

            weekDates.forEach(date => {
                const dateStr = formatDateForChronicle(date);
                if (chronicles[dateStr]) {
                    weekEvents.push(chronicles[dateStr]);
                }
            });

            if (weekEvents.length > 0) {
                result.push({
                    date: weekLabel,
                    text: weekEvents.join('|') // Используем | как разделитель для нескольких событий
                });
            }
        });

        return result;
    }

    // Вспомогательная функция для получения всех дат недели
    function getDatesOfWeek(year, week) {
        const dates = [];
        const firstDay = new Date(year, 0, 1);
        const firstWeekDay = firstDay.getDay() || 7;
        let firstWeekDate = new Date(year, 0, 1 + (8 - firstWeekDay) % 7);

        if (week > 1) {
            firstWeekDate.setDate(firstWeekDate.getDate() + (week - 1) * 7);
        }

        for (let i = 0; i < 7; i++) {
            const date = new Date(firstWeekDate);
            date.setDate(date.getDate() + i);
            dates.push(date);
        }

        return dates;
    }

    // Форматирование даты для сравнения с chronicles
    function formatDateForChronicle(date) {
        return date.toISOString().split('T')[0];
    }

    let chronicles = {};
    function getChronicles() {
        const dateFrom = document.getElementById('date_start').value;
        const dateTo = document.getElementById('date_end').value;

        return new Promise((resolve, reject) => {
            $.ajax({
                url: `/api/chronicles_daytime`,
                data: {dateFrom: dateFrom, dateTo: dateTo},
                success: function (data) {
                    chronicles = {};

                    // Собираем все события по датам
                    const eventsByDate = {};

                    for (const [key, value] of Object.entries(data)) {
                        const dateOnly = key.split('T')[0];

                        if (!eventsByDate[dateOnly]) {
                            eventsByDate[dateOnly] = [];
                        }

                        eventsByDate[dateOnly].push(value);
                    }

                    for (const [date, events] of Object.entries(eventsByDate)) {
                        if (events.length === 1) {
                            chronicles[date] = events[0];
                        } else {
                            chronicles[date] = events.join(' | ');
                        }
                    }

                    resolve();
                },
                error: function(error) {
                    reject(error);
                }
            });
        });
    }

    function getChroniclesInRange(labels, dateFrom, dateTo) {
        const result = [];
        labels.forEach(date => {
            if (chronicles[date]) {
                result.push({
                    date: date,
                    text: chronicles[date]
                });
            }
        });
        return result;
    }

    function format_date(date) {
        let month = date.getMonth() + 1
        if (month < 10)
            month = "0" + month
        let day = date.getDate()
        if (day < 10)
            day = "0" + day
        return `${date.getFullYear()}-${month}-${day}`
    }

    get_announce()
    get_achievement()
    get_last_phrase()
    get_flavor()
    get_online_charts()

</script>